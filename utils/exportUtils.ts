import { DatabaseSchema, Table } from '../types';

export const generatePrismaSchema = (schema: DatabaseSchema): string => {
    let output = `// Prisma Schema generated by DB Architect

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
`;

    schema.tables.forEach(table => {
        output += `\nmodel ${toPascalCase(table.name)} {\n`;

        // Columns
        table.columns.forEach(col => {
            const type = mapToPrismaType(col.type);
            let modifiers = '';

            if (col.isPrimaryKey) modifiers += ' @id';
            if (col.type.includes('SERIAL')) modifiers += ' @default(autoincrement())';
            else if (col.type === 'UUID' && col.isPrimaryKey) modifiers += ' @default(uuid())';
            else if (col.isUnique) modifiers += ' @unique';

            if (!col.isPrimaryKey && !col.nullable) {
                // In Prisma, type without ? is required
            } else if (col.nullable) {
                modifiers += '?';
            }

            // Relations (Basic inference)
            // Note: Full relation mapping in Prisma is complex (requires fields/references on both sides). 
            // This is a simplified generation.

            output += `  ${toCamelCase(col.name)} ${type}${modifiers}\n`;
        });

        // Add relations based on Schema Relationships
        // This is tricky because we need the field name. 
        // We'll skip detailed relation fields for this basic version to avoid syntax errors 
        // without deep analysis of both sides of the relation.

        output += `}\n`;
    });

    return output;
};

export const generateTypeORMEntries = (schema: DatabaseSchema): string => {
    let output = `import { Entity, PrimaryGeneratedColumn, Column, OneToOne, OneToMany, ManyToOne, JoinColumn } from "typeorm";\n\n`;

    schema.tables.forEach(table => {
        output += `@Entity('${table.name}')\nexport class ${toPascalCase(table.name)} {\n`;

        table.columns.forEach(col => {
            if (col.isPrimaryKey) {
                if (col.type.includes('SERIAL')) {
                    output += `  @PrimaryGeneratedColumn()\n  ${toCamelCase(col.name)}: number;\n\n`;
                } else {
                    output += `  @PrimaryColumn()\n  ${toCamelCase(col.name)}: string;\n\n`;
                }
            } else {
                // Skip FK columns if we want to use relationships, but for now lets keep them as columns
                // Map types
                const type = mapToTypeORMType(col.type);
                output += `  @Column({ type: '${type}' ${col.nullable ? ', nullable: true' : ''} })\n  ${toCamelCase(col.name)}: ${mapToTSType(col.type)};\n\n`;
            }
        });

        output += `}\n\n`;
    });

    return output;
};

// --- Helpers ---

const toPascalCase = (str: string) => {
    return str.replace(/(?:^|[-_])(\w)/g, (_, c) => c ? c.toUpperCase() : '').replace(/[-_]/g, '');
};

const toCamelCase = (str: string) => {
    return str.replace(/([-_][a-z])/ig, ($1) => {
        return $1.toUpperCase()
            .replace('-', '')
            .replace('_', '');
    });
};

const mapToPrismaType = (sqlType: string): string => {
    const base = sqlType.split('(')[0].toUpperCase();
    if (['INT', 'SERIAL', 'SMALLINT'].includes(base)) return 'Int';
    if (['BIGINT'].includes(base)) return 'BigInt';
    if (['VARCHAR', 'TEXT', 'CHAR'].includes(base)) return 'String';
    if (['BOOLEAN'].includes(base)) return 'Boolean';
    if (['TIMESTAMP', 'DATE', 'DATETIME'].includes(base)) return 'DateTime';
    if (['DECIMAL', 'NUMERIC', 'FLOAT', 'DOUBLE'].includes(base)) return 'Decimal';
    if (['JSON', 'JSONB'].includes(base)) return 'Json';
    return 'String'; // Fallback
};

const mapToTypeORMType = (sqlType: string): string => {
    const base = sqlType.split('(')[0].toLowerCase();
    if (base === 'serial') return 'int'; // TypeORM uses int for serial usually
    return base;
};

const mapToTSType = (sqlType: string): string => {
    const base = sqlType.split('(')[0].toUpperCase();
    if (['INT', 'SERIAL', 'SMALLINT', 'FLOAT', 'DOUBLE', 'DECIMAL', 'NUMERIC'].includes(base)) return 'number';
    if (['BOOLEAN'].includes(base)) return 'boolean';
    if (['TIMESTAMP', 'DATE', 'DATETIME'].includes(base)) return 'Date';
    return 'string';
};
